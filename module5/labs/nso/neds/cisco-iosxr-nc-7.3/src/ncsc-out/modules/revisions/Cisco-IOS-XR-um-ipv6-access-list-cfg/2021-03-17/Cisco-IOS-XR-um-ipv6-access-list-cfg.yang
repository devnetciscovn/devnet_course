module Cisco-IOS-XR-um-ipv6-access-list-cfg {
  // Generated by yanger -t ncs
  tailf:mount-id "cisco-iosxr-nc-7.3:cisco-iosxr-nc-7.3";
  tailf:ncs-device-type "netconf";

  namespace "http://cisco.com/ns/yang/Cisco-IOS-XR-um-ipv6-access-list-cfg";
  prefix um-ipv6-acl-cfg;

  import cisco-semver {
    prefix semver;
  }
  import ietf-inet-types {
    prefix inet;
  }
  import Cisco-IOS-XR-um-access-list-datatypes {
    prefix um-acl-types;
  }
  import Cisco-IOS-XR-types {
    prefix xr2;
  }
  import tailf-common {
    prefix tailf;
  }
  import tailf-ncs {
    prefix ncs;
  }

  organization
    "Cisco Systems, Inc.";
  contact
    "
     Cisco Systems, Inc.
     Customer Service

     Postal: 170 W Tasman Drive
     San Jose, CA 95134

     Tel: +1 1800 553-NETS

     E-mail: cs-yang@cisco.com
    ";
  description
    "
     This module contains a collection of IOS-XR YANG model derived from CLI.

     Copyright (c) 2019-2021 by Cisco Systems, Inc.
     All rights reserved.
    ";

  revision 2021-03-17 {
    description
      "Adding new protocols - vrrp, rsvp
       2021-02-24
         Added container police";
    semver:module-version "1.1.0";
  }
  revision 2021-01-12 {
    description
      "Added udf support";
    semver:module-version "1.0.0";
  }
  revision 2020-12-03 {
    description
      "Limit length of remark string";
  }
  revision 2019-06-10 {
    description
      "Establish semantic version baseline.";
    semver:module-version "1.0.0";
  }
  revision 2019-04-01 {
    description
      "Initial version";
  }

  grouping ncs_template_ace-common {
    container source {
      // NCS drop must statement
      uses ncs_template_source-address;
    }
    container destination {
      // NCS drop must statement
      uses ncs_template_destination-address;
    }
    uses ncs_template_tcp-flags {
      // NCS drop when statement
    }
    uses ncs_template_icmp {
      // NCS drop when statement
    }
    uses ncs_template_undetermined-transport;
    uses ncs_template_headers;
    uses ncs_template_dscp;
    uses ncs_template_packet-length;
    uses ncs_template_ttl;
    uses ncs_template_udf;
    uses ncs_template_police;
  }

  grouping ncs_template_source-address {
    leaf address {
      type string;
      // NCS drop must statement
      description
        "Source IP address";
    }
    leaf wildcard-mask {
      type string;
      // NCS drop must statement
      description
        "Source IP address mask. Either wildcard-mask or prefix-length is supported along with address.";
    }
    leaf prefix-length {
      type xr2:ncs_template_Ipv6-prefix-length;
      // NCS drop must statement
      description
        "Source IP address prefix length.Either wildcard-mask or prefix-length is supported along with address.";
    }
    container any {
      // NCS drop must statement
      presence "Any host";
      description
        "Any source host";
    }
    leaf host {
      type string;
      // NCS drop must statement
      description
        "A single source host";
    }
    leaf net-group {
      // NCS drop if-feature statement
      type string;
      // NCS drop must statement
      description
        "IPv6 source network object group";
    }
    container port {
      // NCS drop when statement
      description
        "Match based on a port number";
      leaf eq {
        type um-acl-types:ncs_template_ipv6-port-number;
        // NCS drop must statement
        description
          "Match only packets on a given port number";
      }
      leaf gt {
        type um-acl-types:ncs_template_ipv6-port-number;
        // NCS drop must statement
        description
          "Match only packet with a greater port number";
      }
      leaf lt {
        type um-acl-types:ncs_template_ipv6-port-number;
        // NCS drop must statement
        description
          "Match only packets with a lower port number";
      }
      leaf neq {
        type um-acl-types:ncs_template_ipv6-port-number;
        // NCS drop must statement
        description
          "Match only packets not on a given port";
      }
      container range {
        description
          "Match only packets in the range of port numbers";
        leaf start-value {
          type um-acl-types:ncs_template_ipv6-port-number;
          // NCS drop must statement
          description
            "Port number";
        }
        leaf end-value {
          type um-acl-types:ncs_template_ipv6-port-number;
          // NCS drop must statement
          description
            "Port number";
        }
      }
    }
    leaf port-group {
      // NCS drop when statement
      // NCS drop if-feature statement
      type string;
      description
        "source port object group";
    }
  }

  grouping ncs_template_destination-address {
    leaf address {
      type string;
      // NCS drop must statement
      description
        "Destination IP address";
    }
    leaf wildcard-mask {
      type string;
      // NCS drop must statement
      description
        "Destination IP address mask. Either wildcard-mask or prefix-length is supported along with address.";
    }
    leaf prefix-length {
      type xr2:ncs_template_Ipv6-prefix-length;
      // NCS drop must statement
      description
        "Destination IP address prefix length.Either wildcard-mask or prefix-length is supported along with address.";
    }
    container any {
      // NCS drop must statement
      presence "Any host";
      description
        "Any destination host";
    }
    leaf host {
      type string;
      // NCS drop must statement
      description
        "A single destination host";
    }
    leaf net-group {
      // NCS drop if-feature statement
      type string;
      // NCS drop must statement
      description
        "IPv6 destination network object group";
    }
    container port {
      // NCS drop when statement
      description
        "Match based on a port number";
      leaf eq {
        type um-acl-types:ncs_template_ipv6-port-number;
        // NCS drop must statement
        description
          "Match only packets on a given port number";
      }
      leaf gt {
        type um-acl-types:ncs_template_ipv6-port-number;
        // NCS drop must statement
        description
          "Match only packet with a greater port number";
      }
      leaf lt {
        type um-acl-types:ncs_template_ipv6-port-number;
        // NCS drop must statement
        description
          "Match only packets with a lower port number";
      }
      leaf neq {
        type um-acl-types:ncs_template_ipv6-port-number;
        // NCS drop must statement
        description
          "Match only packets not on a given port";
      }
      container range {
        description
          "Match only packets in the range of port numbers";
        leaf start-value {
          type um-acl-types:ncs_template_ipv6-port-number;
          // NCS drop must statement
          description
            "Port number";
        }
        leaf end-value {
          type um-acl-types:ncs_template_ipv6-port-number;
          // NCS drop must statement
          description
            "Port number";
        }
      }
    }
    leaf port-group {
      // NCS drop when statement
      // NCS drop if-feature statement
      type string;
      description
        "destination port object group";
    }
  }

  grouping ncs_template_tcp-flags {
    container tcp-flags {
      container match-all {
        // NCS drop if-feature statement
        // NCS drop must statement
        presence "indicates match-all is configured";
        description
          "Match all the options specified for TCP flags";
        leaf tcp-bits {
          type string;
          description
            "TCP bits to match with set(+) or not set(-) indication";
        }
      }
      container match-any {
        // NCS drop if-feature statement
        // NCS drop must statement
        presence "indicates match-any is configured";
        description
          "Match atleast one of the options specified for TCP flags";
        leaf tcp-bits {
          type string;
          description
            "TCP bits to match with set(+) or not set(-) indication";
        }
      }
      leaf tcp-bits {
        type um-acl-types:ncs_template_tcp-bits-type;
        // NCS drop must statement
        description
          "TCP bits to match";
      }
    }
  }

  grouping ncs_template_icmp {
    container icmp {
      description
        "Match on ICMP message";
      leaf message-type-name {
        type um-acl-types:ncs_template_ipv6-icmp-message-type;
        // NCS drop must statement
        description
          "ICMP message type";
      }
      leaf message-type {
        type string;
        // NCS drop must statement
        description
          "ICMP message type";
      }
      leaf message-code {
        type string;
        // NCS drop must statement
        description
          "ICMP message code";
      }
    }
  }

  grouping ncs_template_dscp {
    container dscp {
      description
        "Match packets with given DSCP value(s)";
      leaf dscp-value {
        type um-acl-types:ncs_template_dscp-value;
        // NCS drop must statement
      }
      leaf eq {
        type um-acl-types:ncs_template_dscp-value;
        // NCS drop must statement
        description
          "Match only packets on a given DSCP value";
      }
      leaf gt {
        type um-acl-types:ncs_template_dscp-value;
        // NCS drop must statement
        description
          "Match only packet with a greater DSCP value";
      }
      leaf lt {
        type um-acl-types:ncs_template_dscp-value;
        // NCS drop must statement
        description
          "Match only packets with a lower DSCP value";
      }
      leaf neq {
        type um-acl-types:ncs_template_dscp-value;
        // NCS drop must statement
        description
          "Match only packets not on a given DSCP value";
      }
      container range {
        description
          "Match only packets in the range of DSCP values";
        leaf start-value {
          type um-acl-types:ncs_template_dscp-value;
          // NCS drop must statement
          description
            "DSCP value";
        }
        leaf end-value {
          type um-acl-types:ncs_template_dscp-value;
          // NCS drop must statement
          description
            "DSCP value";
        }
      }
    }
    leaf precedence {
      type um-acl-types:ncs_template_precedence-value;
      description
        "Match packets with given precedence";
    }
  }

  grouping ncs_template_packet-length {
    container packet-length {
      // NCS drop if-feature statement
      description
        "Check packet length";
      leaf eq {
        type string;
        // NCS drop must statement
        description
          "Match only packets with a given value";
      }
      leaf gt {
        type string;
        // NCS drop must statement
        description
          "Match only packet with a greater value";
      }
      leaf lt {
        type string;
        // NCS drop must statement
        description
          "Match only packets with a lower value";
      }
      leaf neq {
        type string;
        // NCS drop must statement
        description
          "Match only packets not on a given value";
      }
      container range {
        description
          "Match only packets in the range of value";
        leaf start-value {
          type string;
          // NCS drop must statement
          description
            "Packet length start";
        }
        leaf end-value {
          type string;
          // NCS drop must statement
          description
            "Packet length end";
        }
      }
    }
  }

  grouping ncs_template_ttl {
    container ttl {
      description
        "match against ttl";
      leaf eq {
        type string;
        // NCS drop must statement
        description
          "Match only packets with a given value";
      }
      leaf gt {
        type string;
        // NCS drop must statement
        description
          "Match only packet with a greater value";
      }
      leaf lt {
        type string;
        // NCS drop must statement
        description
          "Match only packets with a lower value";
      }
      leaf neq {
        type string;
        // NCS drop must statement
        description
          "Match only packets not on a given value";
      }
      container range {
        description
          "Match only packets in the range of value";
        leaf start-value {
          type string;
          // NCS drop must statement
          description
            "ttl range lower value";
        }
        leaf end-value {
          type string;
          // NCS drop must statement
          description
            "ttl range higher value";
        }
      }
    }
  }

  grouping ncs_template_undetermined-transport {
    container undetermined-transport {
      // NCS drop if-feature statement
      presence "Undetermined transport packet (L4 protocol cannot be read)";
      description
        "Undetermined transport packet (L4 protocol cannot be read)";
    }
  }

  grouping ncs_template_headers {
    leaf headers {
      type um-acl-types:ncs_template_header-bits-type;
      description
        "Match based on headers";
    }
  }

  grouping ncs_template_udf {
    list udf {
      // NCS patched for predictable order
      ordered-by user;
      // NCS drop if-feature statement
      key "udf-name";
      // NCS drop max-elements statement
      description
        "Set User Defined Fields on this entry";
      leaf udf-name {
        type string;
        description
          "UDF name";
      }
      leaf udf-value {
        type xr2:ncs_template_Hex-integer;
        description
          "UDF value";
      }
      leaf udf-mask {
        type xr2:ncs_template_Hex-integer;
        description
          "UDF mask";
      }
    }
  }

  grouping ncs_template_police {
    container police {
      description
        "Set Police value and unit on this entry";
      leaf value {
        type string;
        // NCS drop must statement
        description
          "Police value";
      }
      leaf unit {
        type string;
        // NCS drop must statement
        description
          "Unit for police value. Currently only pps (packets per second)
           is supported";
      }
      leaf peak-rate {
        type string;
        // NCS drop must statement
        description
          "Police peak-rate value on this entry";
      }
      leaf peak-unit {
        type string;
        // NCS drop must statement
        description
          "Unit for peak-rate value. Currently only pps (packets per second)
           is supported";
      }
      leaf priority {
        type string;
        // NCS drop must statement
        description
          "Set Priority option on this entry";
      }
    }
  }

  grouping ncs_template_match-option-common {
    container capture {
      // NCS drop if-feature statement
      presence "Capture matched packet";
      description
        "Capture matched packet";
    }
    leaf counter {
      // NCS drop if-feature statement
      type string;
      description
        "counter for this ACE";
    }
    container log {
      presence "Log matches against this entry";
      description
        "Log matches against this entry";
    }
    container log-input {
      presence "Log matches against this entry, including input interface";
      description
        "Log matches against this entry, including input interface";
    }
    container set {
      // NCS drop if-feature statement
      description
        "Set action on this entry";
      leaf qos-group {
        // NCS drop if-feature statement
        type string;
        description
          "qos-group number";
      }
      leaf ttl {
        // NCS drop if-feature statement
        type string;
        description
          "Set ttl value";
      }
    }
  }

  grouping ncs_template_protocol-common {
    leaf protocol {
      type um-acl-types:ncs_template_ipv6-protocol;
      // NCS drop must statement
      description
        "An IPv6 Protocol";
    }
    leaf eq {
      type um-acl-types:ncs_template_ipv6-protocol;
      // NCS drop must statement
      description
        "Match only packets with exact protocol numbers";
    }
    container range {
      // NCS drop if-feature statement
      description
        "Match only packets in the range of protocol numbers";
      leaf start-protocol {
        type um-acl-types:ncs_template_ipv6-protocol;
        // NCS drop must statement
        description
          "An IPv6 Protocol";
      }
      leaf end-protocol {
        type um-acl-types:ncs_template_ipv6-protocol;
        // NCS drop must statement
        description
          "An IPv6 Protocol";
      }
    }
  }

  grouping ncs_template_nexthops {
    container default {
      presence "Use specified default nexthop on match against this entry";
      description
        "Use specified default nexthop on match against this entry";
    }
    container nexthop1 {
      // NCS drop if-feature statement
      presence "Forward to specified nexthop on match against this entry";
      description
        "Forward to specified nexthop on match against this entry";
      leaf ipv6 {
        type string;
        description
          "nexthop1 ipv6 address";
      }
      leaf track {
        // NCS drop if-feature statement
        type string;
        description
          "specific TRACK Name for this nexthop";
      }
      leaf vrf {
        type string;
        description
          "Specific VRF Name for this nexthop";
      }
    }
    container nexthop2 {
      // NCS drop must statement
      presence "Forward to specified nexthop on match against this entry";
      description
        "Another nexthop";
      leaf ipv6 {
        type string;
        description
          "nexthop2 ipv6 address";
      }
      leaf track {
        // NCS drop if-feature statement
        type string;
        description
          "specific TRACK Name for this nexthop";
      }
      leaf vrf {
        type string;
        description
          "Specific VRF Name for this nexthop";
      }
    }
    container nexthop3 {
      // NCS drop must statement
      presence "Forward to specified nexthop on match against this entry";
      description
        "Another nexthop";
      leaf ipv6 {
        type string;
        description
          "nexthop3 ipv6 address";
      }
      leaf track {
        // NCS drop if-feature statement
        type string;
        description
          "specific TRACK Name for this nexthop";
      }
      leaf vrf {
        type string;
        description
          "Specific VRF Name for this nexthop";
      }
    }
  }

  grouping ncs_rpc_notif_ace-common {
    container source {
      must 'address or any or host or net-group' {
        tailf:xpath-root 3;
      }
      uses ncs_rpc_notif_source-address;
    }
    container destination {
      must 'address or any or host or net-group' {
        tailf:xpath-root 3;
      }
      uses ncs_rpc_notif_destination-address;
    }
    uses ncs_rpc_notif_tcp-flags {
      when "protocol='tcp'" {
        tailf:xpath-root 3;
      }
    }
    uses ncs_rpc_notif_icmp {
      when "protocol='icmpv6'" {
        tailf:xpath-root 3;
      }
    }
    uses ncs_rpc_notif_undetermined-transport;
    uses ncs_rpc_notif_headers;
    uses ncs_rpc_notif_dscp;
    uses ncs_rpc_notif_packet-length;
    uses ncs_rpc_notif_ttl;
    uses ncs_rpc_notif_udf;
    uses ncs_rpc_notif_police;
  }

  grouping ncs_rpc_notif_source-address {
    leaf address {
      type inet:ipv6-address;
      must 'not(../any or ../host or ../net-group) and (../wildcard-mask or ../prefix-length)' {
        tailf:xpath-root 3;
      }
      description
        "Source IP address";
    }
    leaf wildcard-mask {
      type inet:ipv6-address-no-zone;
      must 'not(../prefix-length)' {
        tailf:xpath-root 3;
      }
      description
        "Source IP address mask. Either wildcard-mask or prefix-length is supported along with address.";
    }
    leaf prefix-length {
      type xr2:ncs_rpc_notif_Ipv6-prefix-length;
      must 'not(../wildcard-mask)' {
        tailf:xpath-root 3;
      }
      description
        "Source IP address prefix length.Either wildcard-mask or prefix-length is supported along with address.";
    }
    container any {
      must 'not(../address or ../host or ../net-group)' {
        tailf:xpath-root 3;
      }
      presence "Any host";
      description
        "Any source host";
    }
    leaf host {
      type inet:ipv6-address;
      must 'not(../address or ../any or ../net-group)' {
        tailf:xpath-root 3;
      }
      description
        "A single source host";
    }
    leaf net-group {
      tailf:display-when "not(../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../ncs:name]/capability/feature='ipv6_acl_object_groups_supported')";
      type string {
        length "1..64" {
          description
            "IPv6 network object group name";
        }
      }
      must 'not(../address or ../any or ../host)' {
        tailf:xpath-root 3;
      }
      description
        "IPv6 source network object group";
    }
    container port {
      when "../../protocol='tcp' or ../../protocol='sctp' or ../../protocol='udp'" {
        tailf:xpath-root 3;
      }
      description
        "Match based on a port number";
      leaf eq {
        type um-acl-types:ncs_rpc_notif_ipv6-port-number;
        must 'not(../gt or ../lt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets on a given port number";
      }
      leaf gt {
        type um-acl-types:ncs_rpc_notif_ipv6-port-number;
        must 'not(../eq or ../lt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packet with a greater port number";
      }
      leaf lt {
        type um-acl-types:ncs_rpc_notif_ipv6-port-number;
        must 'not(../eq or ../gt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets with a lower port number";
      }
      leaf neq {
        type um-acl-types:ncs_rpc_notif_ipv6-port-number;
        must 'not(../eq or ../gt or ../lt or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets not on a given port";
      }
      container range {
        description
          "Match only packets in the range of port numbers";
        leaf start-value {
          type um-acl-types:ncs_rpc_notif_ipv6-port-number;
          must 'not(../../eq or ../../gt or ../../lt or ../../neq) and (../end-value)' {
            tailf:xpath-root 3;
          }
          description
            "Port number";
        }
        leaf end-value {
          type um-acl-types:ncs_rpc_notif_ipv6-port-number;
          must 'not(../../eq or ../../gt or ../../lt or ../../neq) and (../start-value)' {
            tailf:xpath-root 3;
          }
          description
            "Port number";
        }
      }
    }
    leaf port-group {
      when "../../protocol='tcp' or ../../protocol='sctp' or ../../protocol='udp'" {
        tailf:xpath-root 3;
      }
      tailf:display-when "not(../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../ncs:name]/capability/feature='ipv6_acl_object_groups_supported')";
      type string {
        length "1..64";
      }
      description
        "source port object group";
    }
  }

  grouping ncs_rpc_notif_destination-address {
    leaf address {
      type inet:ipv6-address;
      must 'not(../any or ../host or ../net-group) and (../wildcard-mask or ../prefix-length)' {
        tailf:xpath-root 3;
      }
      description
        "Destination IP address";
    }
    leaf wildcard-mask {
      type inet:ipv6-address-no-zone;
      must 'not(../prefix-length)' {
        tailf:xpath-root 3;
      }
      description
        "Destination IP address mask. Either wildcard-mask or prefix-length is supported along with address.";
    }
    leaf prefix-length {
      type xr2:ncs_rpc_notif_Ipv6-prefix-length;
      must 'not(../wildcard-mask)' {
        tailf:xpath-root 3;
      }
      description
        "Destination IP address prefix length.Either wildcard-mask or prefix-length is supported along with address.";
    }
    container any {
      must 'not(../address or ../host or ../net-group)' {
        tailf:xpath-root 3;
      }
      presence "Any host";
      description
        "Any destination host";
    }
    leaf host {
      type inet:ipv6-address;
      must 'not(../address or ../any or ../net-group)' {
        tailf:xpath-root 3;
      }
      description
        "A single destination host";
    }
    leaf net-group {
      tailf:display-when "not(../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../ncs:name]/capability/feature='ipv6_acl_object_groups_supported')";
      type string {
        length "1..64" {
          description
            "IPv6 network object group name";
        }
      }
      must 'not(../address or ../any or ../host)' {
        tailf:xpath-root 3;
      }
      description
        "IPv6 destination network object group";
    }
    container port {
      when "../../protocol='tcp' or ../../protocol='sctp' or ../../protocol='udp'" {
        tailf:xpath-root 3;
      }
      description
        "Match based on a port number";
      leaf eq {
        type um-acl-types:ncs_rpc_notif_ipv6-port-number;
        must 'not(../gt or ../lt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets on a given port number";
      }
      leaf gt {
        type um-acl-types:ncs_rpc_notif_ipv6-port-number;
        must 'not(../eq or ../lt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packet with a greater port number";
      }
      leaf lt {
        type um-acl-types:ncs_rpc_notif_ipv6-port-number;
        must 'not(../eq or ../gt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets with a lower port number";
      }
      leaf neq {
        type um-acl-types:ncs_rpc_notif_ipv6-port-number;
        must 'not(../eq or ../gt or ../lt or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets not on a given port";
      }
      container range {
        description
          "Match only packets in the range of port numbers";
        leaf start-value {
          type um-acl-types:ncs_rpc_notif_ipv6-port-number;
          must 'not(../../eq or ../../gt or ../../lt or ../../neq) and (../end-value)' {
            tailf:xpath-root 3;
          }
          description
            "Port number";
        }
        leaf end-value {
          type um-acl-types:ncs_rpc_notif_ipv6-port-number;
          must 'not(../../eq or ../../gt or ../../lt or ../../neq) and (../start-value)' {
            tailf:xpath-root 3;
          }
          description
            "Port number";
        }
      }
    }
    leaf port-group {
      when "../../protocol='tcp' or ../../protocol='sctp' or ../../protocol='udp'" {
        tailf:xpath-root 3;
      }
      tailf:display-when "not(../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../ncs:name]/capability/feature='ipv6_acl_object_groups_supported')";
      type string {
        length "1..64";
      }
      description
        "destination port object group";
    }
  }

  grouping ncs_rpc_notif_tcp-flags {
    container tcp-flags {
      container match-all {
        tailf:display-when "not(../../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../../ncs:name]/capability/feature='IP_ACL_TCP_FLEXFLAGS_IMPLEMENTED')";
        must 'not(../match-any)' {
          tailf:xpath-root 3;
        }
        presence "indicates match-all is configured";
        description
          "Match all the options specified for TCP flags";
        leaf tcp-bits {
          type string {
            pattern '((\+|\-)(fin|syn|rst|psh|ack|urg)[ ]{0,1})+' {
              description
                "TCP flags with + or -";
            }
          }
          description
            "TCP bits to match with set(+) or not set(-) indication";
        }
      }
      container match-any {
        tailf:display-when "not(../../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../../ncs:name]/capability/feature='IP_ACL_TCP_FLEXFLAGS_IMPLEMENTED')";
        must 'not(../match-all)' {
          tailf:xpath-root 3;
        }
        presence "indicates match-any is configured";
        description
          "Match atleast one of the options specified for TCP flags";
        leaf tcp-bits {
          type string {
            pattern '((\+|\-)(fin|syn|rst|psh|ack|urg)[ ]{0,1})+' {
              description
                "TCP flags with + or -";
            }
          }
          description
            "TCP bits to match with set(+) or not set(-) indication";
        }
      }
      leaf tcp-bits {
        type um-acl-types:ncs_rpc_notif_tcp-bits-type;
        must 'not(../match-all) and not(../match-any)' {
          tailf:xpath-root 3;
        }
        description
          "TCP bits to match";
      }
    }
  }

  grouping ncs_rpc_notif_icmp {
    container icmp {
      description
        "Match on ICMP message";
      leaf message-type-name {
        type um-acl-types:ncs_rpc_notif_ipv6-icmp-message-type;
        must 'not(../message-type or ../message-code)' {
          tailf:xpath-root 3;
        }
        description
          "ICMP message type";
      }
      leaf message-type {
        type uint8 {
          range "0..255";
        }
        must 'not(../message-type-name)' {
          tailf:xpath-root 3;
        }
        description
          "ICMP message type";
      }
      leaf message-code {
        type uint8 {
          range "0..255";
        }
        must 'not(../message-type-name)' {
          tailf:xpath-root 3;
        }
        description
          "ICMP message code";
      }
    }
  }

  grouping ncs_rpc_notif_dscp {
    container dscp {
      description
        "Match packets with given DSCP value(s)";
      leaf dscp-value {
        type um-acl-types:ncs_rpc_notif_dscp-value;
        must 'not(../eq or ../gt or ../lt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
      }
      leaf eq {
        type um-acl-types:ncs_rpc_notif_dscp-value;
        must 'not(../dscp-value or ../gt or ../lt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets on a given DSCP value";
      }
      leaf gt {
        type um-acl-types:ncs_rpc_notif_dscp-value;
        must 'not(../dscp-value or ../eq or ../lt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packet with a greater DSCP value";
      }
      leaf lt {
        type um-acl-types:ncs_rpc_notif_dscp-value;
        must 'not(../dscp-value or ../eq or ../gt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets with a lower DSCP value";
      }
      leaf neq {
        type um-acl-types:ncs_rpc_notif_dscp-value;
        must 'not(../dscp-value or ../eq or ../gt or ../lt or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets not on a given DSCP value";
      }
      container range {
        description
          "Match only packets in the range of DSCP values";
        leaf start-value {
          type um-acl-types:ncs_rpc_notif_dscp-value;
          must 'not(../../dscp-value or ../../eq or ../../gt or ../../lt or ../../neq) and (../end-value)' {
            tailf:xpath-root 3;
          }
          description
            "DSCP value";
        }
        leaf end-value {
          type um-acl-types:ncs_rpc_notif_dscp-value;
          must 'not(../../dscp-value or ../../eq or ../../gt or ../../lt or ../../neq) and (../start-value)' {
            tailf:xpath-root 3;
          }
          description
            "DSCP value";
        }
      }
    }
    leaf precedence {
      type um-acl-types:ncs_rpc_notif_precedence-value;
      description
        "Match packets with given precedence";
    }
  }

  grouping ncs_rpc_notif_packet-length {
    container packet-length {
      tailf:display-when "not(../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../ncs:name]/capability/feature='ipv6_acl_pktlen_implemented')";
      description
        "Check packet length";
      leaf eq {
        type uint16 {
          range "0..65535";
        }
        must 'not(../gt or ../lt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets with a given value";
      }
      leaf gt {
        type uint16 {
          range "0..65535";
        }
        must 'not(../eq or ../lt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packet with a greater value";
      }
      leaf lt {
        type uint16 {
          range "0..65535";
        }
        must 'not(../eq or ../gt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets with a lower value";
      }
      leaf neq {
        type uint16 {
          range "0..65535";
        }
        must 'not(../eq or ../gt or ../lt or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets not on a given value";
      }
      container range {
        description
          "Match only packets in the range of value";
        leaf start-value {
          type uint16 {
            range "0..65535";
          }
          must 'not(../../eq or ../../gt or ../../lt or ../../neq) and (../end-value)' {
            tailf:xpath-root 3;
          }
          description
            "Packet length start";
        }
        leaf end-value {
          type uint16 {
            range "0..65535";
          }
          must 'not(../../eq or ../../gt or ../../lt or ../../neq) and (../start-value)' {
            tailf:xpath-root 3;
          }
          description
            "Packet length end";
        }
      }
    }
  }

  grouping ncs_rpc_notif_ttl {
    container ttl {
      description
        "match against ttl";
      leaf eq {
        type uint8 {
          range "0..255";
        }
        must 'not(../gt or ../lt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets with a given value";
      }
      leaf gt {
        type uint8 {
          range "0..255";
        }
        must 'not(../eq or ../lt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packet with a greater value";
      }
      leaf lt {
        type uint8 {
          range "0..255";
        }
        must 'not(../eq or ../gt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets with a lower value";
      }
      leaf neq {
        type uint8 {
          range "0..255";
        }
        must 'not(../eq or ../gt or ../lt or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets not on a given value";
      }
      container range {
        description
          "Match only packets in the range of value";
        leaf start-value {
          type uint8 {
            range "0..255";
          }
          must 'not(../../eq or ../../gt or ../../lt or ../../neq) and (../end-value)' {
            tailf:xpath-root 3;
          }
          description
            "ttl range lower value";
        }
        leaf end-value {
          type uint8 {
            range "0..255";
          }
          must 'not(../../eq or ../../gt or ../../lt or ../../neq) and (../start-value)' {
            tailf:xpath-root 3;
          }
          description
            "ttl range higher value";
        }
      }
    }
  }

  grouping ncs_rpc_notif_undetermined-transport {
    container undetermined-transport {
      tailf:display-when "not(../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../ncs:name]/capability/feature='ipv6_acl_undetermined_transport_supported')";
      presence "Undetermined transport packet (L4 protocol cannot be read)";
      description
        "Undetermined transport packet (L4 protocol cannot be read)";
    }
  }

  grouping ncs_rpc_notif_headers {
    leaf headers {
      type um-acl-types:ncs_rpc_notif_header-bits-type;
      description
        "Match based on headers";
    }
  }

  grouping ncs_rpc_notif_udf {
    list udf {
      tailf:display-when "not(ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/ncs:name]/capability/feature='ipv6_acl_is_udf_supported')";
      key "udf-name";
      max-elements 8;
      description
        "Set User Defined Fields on this entry";
      leaf udf-name {
        type string {
          length "1..16";
        }
        description
          "UDF name";
      }
      leaf udf-value {
        type xr2:ncs_rpc_notif_Hex-integer;
        description
          "UDF value";
      }
      leaf udf-mask {
        type xr2:ncs_rpc_notif_Hex-integer;
        description
          "UDF mask";
      }
    }
  }

  grouping ncs_rpc_notif_police {
    container police {
      description
        "Set Police value and unit on this entry";
      leaf value {
        type uint32 {
          range "0..4294967295";
        }
        must '../unit' {
          tailf:xpath-root 3;
        }
        description
          "Police value";
      }
      leaf unit {
        type string {
          pattern 'pps';
        }
        must '../value' {
          tailf:xpath-root 3;
        }
        description
          "Unit for police value. Currently only pps (packets per second)
           is supported";
      }
      leaf peak-rate {
        type uint32 {
          range "0..4294967295";
        }
        must '../value and ../peak-unit' {
          tailf:xpath-root 3;
        }
        description
          "Police peak-rate value on this entry";
      }
      leaf peak-unit {
        type string {
          pattern 'pps';
        }
        must '../peak-rate' {
          tailf:xpath-root 3;
        }
        description
          "Unit for peak-rate value. Currently only pps (packets per second)
           is supported";
      }
      leaf priority {
        type enumeration {
          enum "critical" {
            value 0;
            description
              "punt priority critical";
          }
          enum "high" {
            value 1;
            description
              "punt priority high";
          }
          enum "low" {
            value 2;
            description
              "punt priority low";
          }
          enum "medium" {
            value 3;
            description
              "punt priority medium";
          }
        }
        must '../value' {
          tailf:xpath-root 3;
        }
        description
          "Set Priority option on this entry";
      }
    }
  }

  grouping ncs_rpc_notif_match-option-common {
    container capture {
      tailf:display-when "not(../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../ncs:name]/capability/feature='ipv6_acl_capture_implemented')";
      presence "Capture matched packet";
      description
        "Capture matched packet";
    }
    leaf counter {
      tailf:display-when "not(../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../ncs:name]/capability/feature='ipv6_acl_counter_supported')";
      type string {
        length "1..64" {
          description
            "Name of counter to aggregate hardware statistics";
        }
      }
      description
        "counter for this ACE";
    }
    container log {
      presence "Log matches against this entry";
      description
        "Log matches against this entry";
    }
    container log-input {
      presence "Log matches against this entry, including input interface";
      description
        "Log matches against this entry, including input interface";
    }
    container set {
      tailf:display-when "not(../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../ncs:name]/capability/feature='ipv6_acl_is_set_action_supported')";
      description
        "Set action on this entry";
      leaf qos-group {
        tailf:display-when "not(../../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../../ncs:name]/capability/feature='ipv6_acl_is_set_qos_group_supported')";
        type uint16 {
          range "0..512";
        }
        description
          "qos-group number";
      }
      leaf ttl {
        tailf:display-when "not(../../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../../ncs:name]/capability/feature='ipv6_acl_is_set_ttl_supported')";
        type uint8 {
          range "0..255";
        }
        description
          "Set ttl value";
      }
    }
  }

  grouping ncs_rpc_notif_protocol-common {
    leaf protocol {
      type um-acl-types:ncs_rpc_notif_ipv6-protocol;
      must 'not(../eq or ../range/start-protocol or ../range/end-protocol)' {
        tailf:xpath-root 3;
      }
      description
        "An IPv6 Protocol";
    }
    leaf eq {
      type um-acl-types:ncs_rpc_notif_ipv6-protocol;
      must 'not(../protocol or ../range/start-protocol or ../range/end-protocol)' {
        tailf:xpath-root 3;
      }
      description
        "Match only packets with exact protocol numbers";
    }
    container range {
      tailf:display-when "not(../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../ncs:name]/capability/feature='ipv6_acl_protocol_range_implemented')";
      description
        "Match only packets in the range of protocol numbers";
      leaf start-protocol {
        type um-acl-types:ncs_rpc_notif_ipv6-protocol;
        must 'not(../../protocol or ../../eq) and (../end-protocol)' {
          tailf:xpath-root 3;
        }
        description
          "An IPv6 Protocol";
      }
      leaf end-protocol {
        type um-acl-types:ncs_rpc_notif_ipv6-protocol;
        must 'not(../../protocol or ../../eq) and (../start-protocol)' {
          tailf:xpath-root 3;
        }
        description
          "An IPv6 Protocol";
      }
    }
  }

  grouping ncs_rpc_notif_nexthops {
    container default {
      presence "Use specified default nexthop on match against this entry";
      description
        "Use specified default nexthop on match against this entry";
    }
    container nexthop1 {
      tailf:display-when "not(../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../ncs:name]/capability/feature='ipv6_acl_abf_implemented')";
      presence "Forward to specified nexthop on match against this entry";
      description
        "Forward to specified nexthop on match against this entry";
      leaf ipv6 {
        type inet:ipv6-address;
        description
          "nexthop1 ipv6 address";
      }
      leaf track {
        tailf:display-when "not(../../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../../ncs:name]/capability/feature='ipv6_acl_abf_track_implemented')";
        type string {
          length "1..32";
        }
        description
          "specific TRACK Name for this nexthop";
      }
      leaf vrf {
        type string {
          length "1..32";
        }
        description
          "Specific VRF Name for this nexthop";
      }
    }
    container nexthop2 {
      must '(../nexthop1/vrf and ../nexthop1/ipv6) or ../nexthop1/vrf or ../nexthop1/ipv6' {
        tailf:xpath-root 3;
      }
      presence "Forward to specified nexthop on match against this entry";
      description
        "Another nexthop";
      leaf ipv6 {
        type inet:ipv6-address;
        description
          "nexthop2 ipv6 address";
      }
      leaf track {
        tailf:display-when "not(../../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../../ncs:name]/capability/feature='ipv6_acl_abf_track_implemented')";
        type string {
          length "1..32";
        }
        description
          "specific TRACK Name for this nexthop";
      }
      leaf vrf {
        type string {
          length "1..32";
        }
        description
          "Specific VRF Name for this nexthop";
      }
    }
    container nexthop3 {
      must '(../nexthop2/vrf and ../nexthop2/ipv6) or ../nexthop2/vrf or ../nexthop2/ipv6' {
        tailf:xpath-root 3;
      }
      presence "Forward to specified nexthop on match against this entry";
      description
        "Another nexthop";
      leaf ipv6 {
        type inet:ipv6-address;
        description
          "nexthop3 ipv6 address";
      }
      leaf track {
        tailf:display-when "not(../../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../../ncs:name]/capability/feature='ipv6_acl_abf_track_implemented')";
        type string {
          length "1..32";
        }
        description
          "specific TRACK Name for this nexthop";
      }
      leaf vrf {
        type string {
          length "1..32";
        }
        description
          "Specific VRF Name for this nexthop";
      }
    }
  }

  grouping live_ncs_ace-common {
    container source {
      // NCS drop must statement
      uses live_ncs_source-address;
    }
    container destination {
      // NCS drop must statement
      uses live_ncs_destination-address;
    }
    uses live_ncs_tcp-flags {
      // NCS drop when statement
    }
    uses live_ncs_icmp {
      // NCS drop when statement
    }
    uses live_ncs_undetermined-transport;
    uses live_ncs_headers;
    uses live_ncs_dscp;
    uses live_ncs_packet-length;
    uses live_ncs_ttl;
    uses live_ncs_udf;
    uses live_ncs_police;
  }

  grouping live_ncs_source-address {
    leaf address {
      type inet:ipv6-address;
      // NCS drop must statement
      description
        "Source IP address";
    }
    leaf wildcard-mask {
      type inet:ipv6-address-no-zone;
      // NCS drop must statement
      description
        "Source IP address mask. Either wildcard-mask or prefix-length is supported along with address.";
    }
    leaf prefix-length {
      type xr2:live_ncs_Ipv6-prefix-length;
      // NCS drop must statement
      description
        "Source IP address prefix length.Either wildcard-mask or prefix-length is supported along with address.";
    }
    container any {
      // NCS drop must statement
      presence "Any host";
      description
        "Any source host";
    }
    leaf host {
      type inet:ipv6-address;
      // NCS drop must statement
      description
        "A single source host";
    }
    leaf net-group {
      // NCS drop if-feature statement
      type string {
        length "1..64" {
          description
            "IPv6 network object group name";
        }
      }
      // NCS drop must statement
      description
        "IPv6 source network object group";
    }
    container port {
      // NCS drop when statement
      description
        "Match based on a port number";
      leaf eq {
        type um-acl-types:live_ncs_ipv6-port-number;
        // NCS drop must statement
        description
          "Match only packets on a given port number";
      }
      leaf gt {
        type um-acl-types:live_ncs_ipv6-port-number;
        // NCS drop must statement
        description
          "Match only packet with a greater port number";
      }
      leaf lt {
        type um-acl-types:live_ncs_ipv6-port-number;
        // NCS drop must statement
        description
          "Match only packets with a lower port number";
      }
      leaf neq {
        type um-acl-types:live_ncs_ipv6-port-number;
        // NCS drop must statement
        description
          "Match only packets not on a given port";
      }
      container range {
        description
          "Match only packets in the range of port numbers";
        leaf start-value {
          type um-acl-types:live_ncs_ipv6-port-number;
          // NCS drop must statement
          description
            "Port number";
        }
        leaf end-value {
          type um-acl-types:live_ncs_ipv6-port-number;
          // NCS drop must statement
          description
            "Port number";
        }
      }
    }
    leaf port-group {
      // NCS drop when statement
      // NCS drop if-feature statement
      type string {
        length "1..64";
      }
      description
        "source port object group";
    }
  }

  grouping live_ncs_destination-address {
    leaf address {
      type inet:ipv6-address;
      // NCS drop must statement
      description
        "Destination IP address";
    }
    leaf wildcard-mask {
      type inet:ipv6-address-no-zone;
      // NCS drop must statement
      description
        "Destination IP address mask. Either wildcard-mask or prefix-length is supported along with address.";
    }
    leaf prefix-length {
      type xr2:live_ncs_Ipv6-prefix-length;
      // NCS drop must statement
      description
        "Destination IP address prefix length.Either wildcard-mask or prefix-length is supported along with address.";
    }
    container any {
      // NCS drop must statement
      presence "Any host";
      description
        "Any destination host";
    }
    leaf host {
      type inet:ipv6-address;
      // NCS drop must statement
      description
        "A single destination host";
    }
    leaf net-group {
      // NCS drop if-feature statement
      type string {
        length "1..64" {
          description
            "IPv6 network object group name";
        }
      }
      // NCS drop must statement
      description
        "IPv6 destination network object group";
    }
    container port {
      // NCS drop when statement
      description
        "Match based on a port number";
      leaf eq {
        type um-acl-types:live_ncs_ipv6-port-number;
        // NCS drop must statement
        description
          "Match only packets on a given port number";
      }
      leaf gt {
        type um-acl-types:live_ncs_ipv6-port-number;
        // NCS drop must statement
        description
          "Match only packet with a greater port number";
      }
      leaf lt {
        type um-acl-types:live_ncs_ipv6-port-number;
        // NCS drop must statement
        description
          "Match only packets with a lower port number";
      }
      leaf neq {
        type um-acl-types:live_ncs_ipv6-port-number;
        // NCS drop must statement
        description
          "Match only packets not on a given port";
      }
      container range {
        description
          "Match only packets in the range of port numbers";
        leaf start-value {
          type um-acl-types:live_ncs_ipv6-port-number;
          // NCS drop must statement
          description
            "Port number";
        }
        leaf end-value {
          type um-acl-types:live_ncs_ipv6-port-number;
          // NCS drop must statement
          description
            "Port number";
        }
      }
    }
    leaf port-group {
      // NCS drop when statement
      // NCS drop if-feature statement
      type string {
        length "1..64";
      }
      description
        "destination port object group";
    }
  }

  grouping live_ncs_tcp-flags {
    container tcp-flags {
      container match-all {
        // NCS drop if-feature statement
        // NCS drop must statement
        presence "indicates match-all is configured";
        description
          "Match all the options specified for TCP flags";
        leaf tcp-bits {
          type string {
            pattern '((\+|\-)(fin|syn|rst|psh|ack|urg)[ ]{0,1})+' {
              description
                "TCP flags with + or -";
            }
          }
          description
            "TCP bits to match with set(+) or not set(-) indication";
        }
      }
      container match-any {
        // NCS drop if-feature statement
        // NCS drop must statement
        presence "indicates match-any is configured";
        description
          "Match atleast one of the options specified for TCP flags";
        leaf tcp-bits {
          type string {
            pattern '((\+|\-)(fin|syn|rst|psh|ack|urg)[ ]{0,1})+' {
              description
                "TCP flags with + or -";
            }
          }
          description
            "TCP bits to match with set(+) or not set(-) indication";
        }
      }
      leaf tcp-bits {
        type um-acl-types:live_ncs_tcp-bits-type;
        // NCS drop must statement
        description
          "TCP bits to match";
      }
    }
  }

  grouping live_ncs_icmp {
    container icmp {
      description
        "Match on ICMP message";
      leaf message-type-name {
        type um-acl-types:live_ncs_ipv6-icmp-message-type;
        // NCS drop must statement
        description
          "ICMP message type";
      }
      leaf message-type {
        type uint8 {
          range "0..255";
        }
        // NCS drop must statement
        description
          "ICMP message type";
      }
      leaf message-code {
        type uint8 {
          range "0..255";
        }
        // NCS drop must statement
        description
          "ICMP message code";
      }
    }
  }

  grouping live_ncs_dscp {
    container dscp {
      description
        "Match packets with given DSCP value(s)";
      leaf dscp-value {
        type um-acl-types:live_ncs_dscp-value;
        // NCS drop must statement
      }
      leaf eq {
        type um-acl-types:live_ncs_dscp-value;
        // NCS drop must statement
        description
          "Match only packets on a given DSCP value";
      }
      leaf gt {
        type um-acl-types:live_ncs_dscp-value;
        // NCS drop must statement
        description
          "Match only packet with a greater DSCP value";
      }
      leaf lt {
        type um-acl-types:live_ncs_dscp-value;
        // NCS drop must statement
        description
          "Match only packets with a lower DSCP value";
      }
      leaf neq {
        type um-acl-types:live_ncs_dscp-value;
        // NCS drop must statement
        description
          "Match only packets not on a given DSCP value";
      }
      container range {
        description
          "Match only packets in the range of DSCP values";
        leaf start-value {
          type um-acl-types:live_ncs_dscp-value;
          // NCS drop must statement
          description
            "DSCP value";
        }
        leaf end-value {
          type um-acl-types:live_ncs_dscp-value;
          // NCS drop must statement
          description
            "DSCP value";
        }
      }
    }
    leaf precedence {
      type um-acl-types:live_ncs_precedence-value;
      description
        "Match packets with given precedence";
    }
  }

  grouping live_ncs_packet-length {
    container packet-length {
      // NCS drop if-feature statement
      description
        "Check packet length";
      leaf eq {
        type uint16 {
          range "0..65535";
        }
        // NCS drop must statement
        description
          "Match only packets with a given value";
      }
      leaf gt {
        type uint16 {
          range "0..65535";
        }
        // NCS drop must statement
        description
          "Match only packet with a greater value";
      }
      leaf lt {
        type uint16 {
          range "0..65535";
        }
        // NCS drop must statement
        description
          "Match only packets with a lower value";
      }
      leaf neq {
        type uint16 {
          range "0..65535";
        }
        // NCS drop must statement
        description
          "Match only packets not on a given value";
      }
      container range {
        description
          "Match only packets in the range of value";
        leaf start-value {
          type uint16 {
            range "0..65535";
          }
          // NCS drop must statement
          description
            "Packet length start";
        }
        leaf end-value {
          type uint16 {
            range "0..65535";
          }
          // NCS drop must statement
          description
            "Packet length end";
        }
      }
    }
  }

  grouping live_ncs_ttl {
    container ttl {
      description
        "match against ttl";
      leaf eq {
        type uint8 {
          range "0..255";
        }
        // NCS drop must statement
        description
          "Match only packets with a given value";
      }
      leaf gt {
        type uint8 {
          range "0..255";
        }
        // NCS drop must statement
        description
          "Match only packet with a greater value";
      }
      leaf lt {
        type uint8 {
          range "0..255";
        }
        // NCS drop must statement
        description
          "Match only packets with a lower value";
      }
      leaf neq {
        type uint8 {
          range "0..255";
        }
        // NCS drop must statement
        description
          "Match only packets not on a given value";
      }
      container range {
        description
          "Match only packets in the range of value";
        leaf start-value {
          type uint8 {
            range "0..255";
          }
          // NCS drop must statement
          description
            "ttl range lower value";
        }
        leaf end-value {
          type uint8 {
            range "0..255";
          }
          // NCS drop must statement
          description
            "ttl range higher value";
        }
      }
    }
  }

  grouping live_ncs_undetermined-transport {
    container undetermined-transport {
      // NCS drop if-feature statement
      presence "Undetermined transport packet (L4 protocol cannot be read)";
      description
        "Undetermined transport packet (L4 protocol cannot be read)";
    }
  }

  grouping live_ncs_headers {
    leaf headers {
      type um-acl-types:live_ncs_header-bits-type;
      description
        "Match based on headers";
    }
  }

  grouping live_ncs_udf {
    list udf {
      // NCS drop if-feature statement
      key "udf-name";
      // NCS drop max-elements statement
      description
        "Set User Defined Fields on this entry";
      leaf udf-name {
        type string {
          length "1..16";
        }
        description
          "UDF name";
      }
      leaf udf-value {
        type xr2:live_ncs_Hex-integer;
        description
          "UDF value";
      }
      leaf udf-mask {
        type xr2:live_ncs_Hex-integer;
        description
          "UDF mask";
      }
    }
  }

  grouping live_ncs_police {
    container police {
      description
        "Set Police value and unit on this entry";
      leaf value {
        type uint32 {
          range "0..4294967295";
        }
        // NCS drop must statement
        description
          "Police value";
      }
      leaf unit {
        type string {
          pattern 'pps';
        }
        // NCS drop must statement
        description
          "Unit for police value. Currently only pps (packets per second)
           is supported";
      }
      leaf peak-rate {
        type uint32 {
          range "0..4294967295";
        }
        // NCS drop must statement
        description
          "Police peak-rate value on this entry";
      }
      leaf peak-unit {
        type string {
          pattern 'pps';
        }
        // NCS drop must statement
        description
          "Unit for peak-rate value. Currently only pps (packets per second)
           is supported";
      }
      leaf priority {
        type enumeration {
          enum "critical" {
            value 0;
            description
              "punt priority critical";
          }
          enum "high" {
            value 1;
            description
              "punt priority high";
          }
          enum "low" {
            value 2;
            description
              "punt priority low";
          }
          enum "medium" {
            value 3;
            description
              "punt priority medium";
          }
        }
        // NCS drop must statement
        description
          "Set Priority option on this entry";
      }
    }
  }

  grouping live_ncs_match-option-common {
    container capture {
      // NCS drop if-feature statement
      presence "Capture matched packet";
      description
        "Capture matched packet";
    }
    leaf counter {
      // NCS drop if-feature statement
      type string {
        length "1..64" {
          description
            "Name of counter to aggregate hardware statistics";
        }
      }
      description
        "counter for this ACE";
    }
    container log {
      presence "Log matches against this entry";
      description
        "Log matches against this entry";
    }
    container log-input {
      presence "Log matches against this entry, including input interface";
      description
        "Log matches against this entry, including input interface";
    }
    container set {
      // NCS drop if-feature statement
      description
        "Set action on this entry";
      leaf qos-group {
        // NCS drop if-feature statement
        type uint16 {
          range "0..512";
        }
        description
          "qos-group number";
      }
      leaf ttl {
        // NCS drop if-feature statement
        type uint8 {
          range "0..255";
        }
        description
          "Set ttl value";
      }
    }
  }

  grouping live_ncs_protocol-common {
    leaf protocol {
      type um-acl-types:live_ncs_ipv6-protocol;
      // NCS drop must statement
      description
        "An IPv6 Protocol";
    }
    leaf eq {
      type um-acl-types:live_ncs_ipv6-protocol;
      // NCS drop must statement
      description
        "Match only packets with exact protocol numbers";
    }
    container range {
      // NCS drop if-feature statement
      description
        "Match only packets in the range of protocol numbers";
      leaf start-protocol {
        type um-acl-types:live_ncs_ipv6-protocol;
        // NCS drop must statement
        description
          "An IPv6 Protocol";
      }
      leaf end-protocol {
        type um-acl-types:live_ncs_ipv6-protocol;
        // NCS drop must statement
        description
          "An IPv6 Protocol";
      }
    }
  }

  grouping live_ncs_nexthops {
    container default {
      presence "Use specified default nexthop on match against this entry";
      description
        "Use specified default nexthop on match against this entry";
    }
    container nexthop1 {
      // NCS drop if-feature statement
      presence "Forward to specified nexthop on match against this entry";
      description
        "Forward to specified nexthop on match against this entry";
      leaf ipv6 {
        type inet:ipv6-address;
        description
          "nexthop1 ipv6 address";
      }
      leaf track {
        // NCS drop if-feature statement
        type string {
          length "1..32";
        }
        description
          "specific TRACK Name for this nexthop";
      }
      leaf vrf {
        type string {
          length "1..32";
        }
        description
          "Specific VRF Name for this nexthop";
      }
    }
    container nexthop2 {
      // NCS drop must statement
      presence "Forward to specified nexthop on match against this entry";
      description
        "Another nexthop";
      leaf ipv6 {
        type inet:ipv6-address;
        description
          "nexthop2 ipv6 address";
      }
      leaf track {
        // NCS drop if-feature statement
        type string {
          length "1..32";
        }
        description
          "specific TRACK Name for this nexthop";
      }
      leaf vrf {
        type string {
          length "1..32";
        }
        description
          "Specific VRF Name for this nexthop";
      }
    }
    container nexthop3 {
      // NCS drop must statement
      presence "Forward to specified nexthop on match against this entry";
      description
        "Another nexthop";
      leaf ipv6 {
        type inet:ipv6-address;
        description
          "nexthop3 ipv6 address";
      }
      leaf track {
        // NCS drop if-feature statement
        type string {
          length "1..32";
        }
        description
          "specific TRACK Name for this nexthop";
      }
      leaf vrf {
        type string {
          length "1..32";
        }
        description
          "Specific VRF Name for this nexthop";
      }
    }
  }

  grouping ace-common {
    container source {
      must 'address or any or host or net-group' {
        tailf:xpath-root 3;
      }
      uses source-address;
    }
    container destination {
      must 'address or any or host or net-group' {
        tailf:xpath-root 3;
      }
      uses destination-address;
    }
    uses tcp-flags {
      when "protocol='tcp'" {
        tailf:xpath-root 3;
      }
    }
    uses icmp {
      when "protocol='icmpv6'" {
        tailf:xpath-root 3;
      }
    }
    uses undetermined-transport;
    uses headers;
    uses dscp;
    uses packet-length;
    uses ttl;
    uses udf;
    uses police;
  }

  grouping source-address {
    leaf address {
      type inet:ipv6-address;
      must 'not(../any or ../host or ../net-group) and (../wildcard-mask or ../prefix-length)' {
        tailf:xpath-root 3;
      }
      description
        "Source IP address";
    }
    leaf wildcard-mask {
      type inet:ipv6-address-no-zone;
      must 'not(../prefix-length)' {
        tailf:xpath-root 3;
      }
      description
        "Source IP address mask. Either wildcard-mask or prefix-length is supported along with address.";
    }
    leaf prefix-length {
      type xr2:Ipv6-prefix-length;
      must 'not(../wildcard-mask)' {
        tailf:xpath-root 3;
      }
      description
        "Source IP address prefix length.Either wildcard-mask or prefix-length is supported along with address.";
    }
    container any {
      must 'not(../address or ../host or ../net-group)' {
        tailf:xpath-root 3;
      }
      presence "Any host";
      description
        "Any source host";
    }
    leaf host {
      type inet:ipv6-address;
      must 'not(../address or ../any or ../net-group)' {
        tailf:xpath-root 3;
      }
      description
        "A single source host";
    }
    leaf net-group {
      tailf:display-when "not(../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../ncs:name]/capability/feature='ipv6_acl_object_groups_supported')";
      type string {
        length "1..64" {
          description
            "IPv6 network object group name";
        }
      }
      must 'not(../address or ../any or ../host)' {
        tailf:xpath-root 3;
      }
      description
        "IPv6 source network object group";
    }
    container port {
      when "../../protocol='tcp' or ../../protocol='sctp' or ../../protocol='udp'" {
        tailf:xpath-root 3;
      }
      description
        "Match based on a port number";
      leaf eq {
        type um-acl-types:ipv6-port-number;
        must 'not(../gt or ../lt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets on a given port number";
      }
      leaf gt {
        type um-acl-types:ipv6-port-number;
        must 'not(../eq or ../lt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packet with a greater port number";
      }
      leaf lt {
        type um-acl-types:ipv6-port-number;
        must 'not(../eq or ../gt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets with a lower port number";
      }
      leaf neq {
        type um-acl-types:ipv6-port-number;
        must 'not(../eq or ../gt or ../lt or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets not on a given port";
      }
      container range {
        description
          "Match only packets in the range of port numbers";
        leaf start-value {
          type um-acl-types:ipv6-port-number;
          must 'not(../../eq or ../../gt or ../../lt or ../../neq) and (../end-value)' {
            tailf:xpath-root 3;
          }
          description
            "Port number";
        }
        leaf end-value {
          type um-acl-types:ipv6-port-number;
          must 'not(../../eq or ../../gt or ../../lt or ../../neq) and (../start-value)' {
            tailf:xpath-root 3;
          }
          description
            "Port number";
        }
      }
    }
    leaf port-group {
      when "../../protocol='tcp' or ../../protocol='sctp' or ../../protocol='udp'" {
        tailf:xpath-root 3;
      }
      tailf:display-when "not(../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../ncs:name]/capability/feature='ipv6_acl_object_groups_supported')";
      type string {
        length "1..64";
      }
      description
        "source port object group";
    }
  }

  grouping destination-address {
    leaf address {
      type inet:ipv6-address;
      must 'not(../any or ../host or ../net-group) and (../wildcard-mask or ../prefix-length)' {
        tailf:xpath-root 3;
      }
      description
        "Destination IP address";
    }
    leaf wildcard-mask {
      type inet:ipv6-address-no-zone;
      must 'not(../prefix-length)' {
        tailf:xpath-root 3;
      }
      description
        "Destination IP address mask. Either wildcard-mask or prefix-length is supported along with address.";
    }
    leaf prefix-length {
      type xr2:Ipv6-prefix-length;
      must 'not(../wildcard-mask)' {
        tailf:xpath-root 3;
      }
      description
        "Destination IP address prefix length.Either wildcard-mask or prefix-length is supported along with address.";
    }
    container any {
      must 'not(../address or ../host or ../net-group)' {
        tailf:xpath-root 3;
      }
      presence "Any host";
      description
        "Any destination host";
    }
    leaf host {
      type inet:ipv6-address;
      must 'not(../address or ../any or ../net-group)' {
        tailf:xpath-root 3;
      }
      description
        "A single destination host";
    }
    leaf net-group {
      tailf:display-when "not(../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../ncs:name]/capability/feature='ipv6_acl_object_groups_supported')";
      type string {
        length "1..64" {
          description
            "IPv6 network object group name";
        }
      }
      must 'not(../address or ../any or ../host)' {
        tailf:xpath-root 3;
      }
      description
        "IPv6 destination network object group";
    }
    container port {
      when "../../protocol='tcp' or ../../protocol='sctp' or ../../protocol='udp'" {
        tailf:xpath-root 3;
      }
      description
        "Match based on a port number";
      leaf eq {
        type um-acl-types:ipv6-port-number;
        must 'not(../gt or ../lt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets on a given port number";
      }
      leaf gt {
        type um-acl-types:ipv6-port-number;
        must 'not(../eq or ../lt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packet with a greater port number";
      }
      leaf lt {
        type um-acl-types:ipv6-port-number;
        must 'not(../eq or ../gt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets with a lower port number";
      }
      leaf neq {
        type um-acl-types:ipv6-port-number;
        must 'not(../eq or ../gt or ../lt or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets not on a given port";
      }
      container range {
        description
          "Match only packets in the range of port numbers";
        leaf start-value {
          type um-acl-types:ipv6-port-number;
          must 'not(../../eq or ../../gt or ../../lt or ../../neq) and (../end-value)' {
            tailf:xpath-root 3;
          }
          description
            "Port number";
        }
        leaf end-value {
          type um-acl-types:ipv6-port-number;
          must 'not(../../eq or ../../gt or ../../lt or ../../neq) and (../start-value)' {
            tailf:xpath-root 3;
          }
          description
            "Port number";
        }
      }
    }
    leaf port-group {
      when "../../protocol='tcp' or ../../protocol='sctp' or ../../protocol='udp'" {
        tailf:xpath-root 3;
      }
      tailf:display-when "not(../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../ncs:name]/capability/feature='ipv6_acl_object_groups_supported')";
      type string {
        length "1..64";
      }
      description
        "destination port object group";
    }
  }

  grouping tcp-flags {
    container tcp-flags {
      container match-all {
        tailf:display-when "not(../../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../../ncs:name]/capability/feature='IP_ACL_TCP_FLEXFLAGS_IMPLEMENTED')";
        must 'not(../match-any)' {
          tailf:xpath-root 3;
        }
        presence "indicates match-all is configured";
        description
          "Match all the options specified for TCP flags";
        leaf tcp-bits {
          type string {
            pattern '((\+|\-)(fin|syn|rst|psh|ack|urg)[ ]{0,1})+' {
              description
                "TCP flags with + or -";
            }
          }
          description
            "TCP bits to match with set(+) or not set(-) indication";
        }
      }
      container match-any {
        tailf:display-when "not(../../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../../ncs:name]/capability/feature='IP_ACL_TCP_FLEXFLAGS_IMPLEMENTED')";
        must 'not(../match-all)' {
          tailf:xpath-root 3;
        }
        presence "indicates match-any is configured";
        description
          "Match atleast one of the options specified for TCP flags";
        leaf tcp-bits {
          type string {
            pattern '((\+|\-)(fin|syn|rst|psh|ack|urg)[ ]{0,1})+' {
              description
                "TCP flags with + or -";
            }
          }
          description
            "TCP bits to match with set(+) or not set(-) indication";
        }
      }
      leaf tcp-bits {
        type um-acl-types:tcp-bits-type;
        must 'not(../match-all) and not(../match-any)' {
          tailf:xpath-root 3;
        }
        description
          "TCP bits to match";
      }
    }
  }

  grouping icmp {
    container icmp {
      description
        "Match on ICMP message";
      leaf message-type-name {
        type um-acl-types:ipv6-icmp-message-type;
        must 'not(../message-type or ../message-code)' {
          tailf:xpath-root 3;
        }
        description
          "ICMP message type";
      }
      leaf message-type {
        type uint8 {
          range "0..255";
        }
        must 'not(../message-type-name)' {
          tailf:xpath-root 3;
        }
        description
          "ICMP message type";
      }
      leaf message-code {
        type uint8 {
          range "0..255";
        }
        must 'not(../message-type-name)' {
          tailf:xpath-root 3;
        }
        description
          "ICMP message code";
      }
    }
  }

  grouping dscp {
    container dscp {
      description
        "Match packets with given DSCP value(s)";
      leaf dscp-value {
        type um-acl-types:dscp-value;
        must 'not(../eq or ../gt or ../lt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
      }
      leaf eq {
        type um-acl-types:dscp-value;
        must 'not(../dscp-value or ../gt or ../lt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets on a given DSCP value";
      }
      leaf gt {
        type um-acl-types:dscp-value;
        must 'not(../dscp-value or ../eq or ../lt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packet with a greater DSCP value";
      }
      leaf lt {
        type um-acl-types:dscp-value;
        must 'not(../dscp-value or ../eq or ../gt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets with a lower DSCP value";
      }
      leaf neq {
        type um-acl-types:dscp-value;
        must 'not(../dscp-value or ../eq or ../gt or ../lt or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets not on a given DSCP value";
      }
      container range {
        description
          "Match only packets in the range of DSCP values";
        leaf start-value {
          type um-acl-types:dscp-value;
          must 'not(../../dscp-value or ../../eq or ../../gt or ../../lt or ../../neq) and (../end-value)' {
            tailf:xpath-root 3;
          }
          description
            "DSCP value";
        }
        leaf end-value {
          type um-acl-types:dscp-value;
          must 'not(../../dscp-value or ../../eq or ../../gt or ../../lt or ../../neq) and (../start-value)' {
            tailf:xpath-root 3;
          }
          description
            "DSCP value";
        }
      }
    }
    leaf precedence {
      type um-acl-types:precedence-value;
      description
        "Match packets with given precedence";
    }
  }

  grouping packet-length {
    container packet-length {
      tailf:display-when "not(../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../ncs:name]/capability/feature='ipv6_acl_pktlen_implemented')";
      description
        "Check packet length";
      leaf eq {
        type uint16 {
          range "0..65535";
        }
        must 'not(../gt or ../lt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets with a given value";
      }
      leaf gt {
        type uint16 {
          range "0..65535";
        }
        must 'not(../eq or ../lt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packet with a greater value";
      }
      leaf lt {
        type uint16 {
          range "0..65535";
        }
        must 'not(../eq or ../gt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets with a lower value";
      }
      leaf neq {
        type uint16 {
          range "0..65535";
        }
        must 'not(../eq or ../gt or ../lt or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets not on a given value";
      }
      container range {
        description
          "Match only packets in the range of value";
        leaf start-value {
          type uint16 {
            range "0..65535";
          }
          must 'not(../../eq or ../../gt or ../../lt or ../../neq) and (../end-value)' {
            tailf:xpath-root 3;
          }
          description
            "Packet length start";
        }
        leaf end-value {
          type uint16 {
            range "0..65535";
          }
          must 'not(../../eq or ../../gt or ../../lt or ../../neq) and (../start-value)' {
            tailf:xpath-root 3;
          }
          description
            "Packet length end";
        }
      }
    }
  }

  grouping ttl {
    container ttl {
      description
        "match against ttl";
      leaf eq {
        type uint8 {
          range "0..255";
        }
        must 'not(../gt or ../lt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets with a given value";
      }
      leaf gt {
        type uint8 {
          range "0..255";
        }
        must 'not(../eq or ../lt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packet with a greater value";
      }
      leaf lt {
        type uint8 {
          range "0..255";
        }
        must 'not(../eq or ../gt or ../neq or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets with a lower value";
      }
      leaf neq {
        type uint8 {
          range "0..255";
        }
        must 'not(../eq or ../gt or ../lt or ../range/start-value or ../range/end-value)' {
          tailf:xpath-root 3;
        }
        description
          "Match only packets not on a given value";
      }
      container range {
        description
          "Match only packets in the range of value";
        leaf start-value {
          type uint8 {
            range "0..255";
          }
          must 'not(../../eq or ../../gt or ../../lt or ../../neq) and (../end-value)' {
            tailf:xpath-root 3;
          }
          description
            "ttl range lower value";
        }
        leaf end-value {
          type uint8 {
            range "0..255";
          }
          must 'not(../../eq or ../../gt or ../../lt or ../../neq) and (../start-value)' {
            tailf:xpath-root 3;
          }
          description
            "ttl range higher value";
        }
      }
    }
  }

  grouping undetermined-transport {
    container undetermined-transport {
      tailf:display-when "not(../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../ncs:name]/capability/feature='ipv6_acl_undetermined_transport_supported')";
      presence "Undetermined transport packet (L4 protocol cannot be read)";
      description
        "Undetermined transport packet (L4 protocol cannot be read)";
    }
  }

  grouping headers {
    leaf headers {
      type um-acl-types:header-bits-type;
      description
        "Match based on headers";
    }
  }

  grouping udf {
    list udf {
      tailf:display-when "not(ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/ncs:name]/capability/feature='ipv6_acl_is_udf_supported')";
      key "udf-name";
      max-elements 8;
      description
        "Set User Defined Fields on this entry";
      leaf udf-name {
        type string {
          length "1..16";
        }
        description
          "UDF name";
      }
      leaf udf-value {
        type xr2:Hex-integer;
        description
          "UDF value";
      }
      leaf udf-mask {
        type xr2:Hex-integer;
        description
          "UDF mask";
      }
    }
  }

  grouping police {
    container police {
      description
        "Set Police value and unit on this entry";
      leaf value {
        type uint32 {
          range "0..4294967295";
        }
        must '../unit' {
          tailf:xpath-root 3;
        }
        description
          "Police value";
      }
      leaf unit {
        type string {
          pattern 'pps';
        }
        must '../value' {
          tailf:xpath-root 3;
        }
        description
          "Unit for police value. Currently only pps (packets per second)
           is supported";
      }
      leaf peak-rate {
        type uint32 {
          range "0..4294967295";
        }
        must '../value and ../peak-unit' {
          tailf:xpath-root 3;
        }
        description
          "Police peak-rate value on this entry";
      }
      leaf peak-unit {
        type string {
          pattern 'pps';
        }
        must '../peak-rate' {
          tailf:xpath-root 3;
        }
        description
          "Unit for peak-rate value. Currently only pps (packets per second)
           is supported";
      }
      leaf priority {
        type enumeration {
          enum "critical" {
            value 0;
            description
              "punt priority critical";
          }
          enum "high" {
            value 1;
            description
              "punt priority high";
          }
          enum "low" {
            value 2;
            description
              "punt priority low";
          }
          enum "medium" {
            value 3;
            description
              "punt priority medium";
          }
        }
        must '../value' {
          tailf:xpath-root 3;
        }
        description
          "Set Priority option on this entry";
      }
    }
  }

  grouping match-option-common {
    container capture {
      tailf:display-when "not(../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../ncs:name]/capability/feature='ipv6_acl_capture_implemented')";
      presence "Capture matched packet";
      description
        "Capture matched packet";
    }
    leaf counter {
      tailf:display-when "not(../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../ncs:name]/capability/feature='ipv6_acl_counter_supported')";
      type string {
        length "1..64" {
          description
            "Name of counter to aggregate hardware statistics";
        }
      }
      description
        "counter for this ACE";
    }
    container log {
      presence "Log matches against this entry";
      description
        "Log matches against this entry";
    }
    container log-input {
      presence "Log matches against this entry, including input interface";
      description
        "Log matches against this entry, including input interface";
    }
    container set {
      tailf:display-when "not(../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../ncs:name]/capability/feature='ipv6_acl_is_set_action_supported')";
      description
        "Set action on this entry";
      leaf qos-group {
        tailf:display-when "not(../../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../../ncs:name]/capability/feature='ipv6_acl_is_set_qos_group_supported')";
        type uint16 {
          range "0..512";
        }
        description
          "qos-group number";
      }
      leaf ttl {
        tailf:display-when "not(../../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../../ncs:name]/capability/feature='ipv6_acl_is_set_ttl_supported')";
        type uint8 {
          range "0..255";
        }
        description
          "Set ttl value";
      }
    }
  }

  grouping protocol-common {
    leaf protocol {
      type um-acl-types:ipv6-protocol;
      must 'not(../eq or ../range/start-protocol or ../range/end-protocol)' {
        tailf:xpath-root 3;
      }
      description
        "An IPv6 Protocol";
    }
    leaf eq {
      type um-acl-types:ipv6-protocol;
      must 'not(../protocol or ../range/start-protocol or ../range/end-protocol)' {
        tailf:xpath-root 3;
      }
      description
        "Match only packets with exact protocol numbers";
    }
    container range {
      tailf:display-when "not(../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../ncs:name]/capability/feature='ipv6_acl_protocol_range_implemented')";
      description
        "Match only packets in the range of protocol numbers";
      leaf start-protocol {
        type um-acl-types:ipv6-protocol;
        must 'not(../../protocol or ../../eq) and (../end-protocol)' {
          tailf:xpath-root 3;
        }
        description
          "An IPv6 Protocol";
      }
      leaf end-protocol {
        type um-acl-types:ipv6-protocol;
        must 'not(../../protocol or ../../eq) and (../start-protocol)' {
          tailf:xpath-root 3;
        }
        description
          "An IPv6 Protocol";
      }
    }
  }

  grouping nexthops {
    container default {
      presence "Use specified default nexthop on match against this entry";
      description
        "Use specified default nexthop on match against this entry";
    }
    container nexthop1 {
      tailf:display-when "not(../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../ncs:name]/capability/feature='ipv6_acl_abf_implemented')";
      presence "Forward to specified nexthop on match against this entry";
      description
        "Forward to specified nexthop on match against this entry";
      leaf ipv6 {
        type inet:ipv6-address;
        description
          "nexthop1 ipv6 address";
      }
      leaf track {
        tailf:display-when "not(../../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../../ncs:name]/capability/feature='ipv6_acl_abf_track_implemented')";
        type string {
          length "1..32";
        }
        description
          "specific TRACK Name for this nexthop";
      }
      leaf vrf {
        type string {
          length "1..32";
        }
        description
          "Specific VRF Name for this nexthop";
      }
    }
    container nexthop2 {
      must '(../nexthop1/vrf and ../nexthop1/ipv6) or ../nexthop1/vrf or ../nexthop1/ipv6' {
        tailf:xpath-root 3;
      }
      presence "Forward to specified nexthop on match against this entry";
      description
        "Another nexthop";
      leaf ipv6 {
        type inet:ipv6-address;
        description
          "nexthop2 ipv6 address";
      }
      leaf track {
        tailf:display-when "not(../../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../../ncs:name]/capability/feature='ipv6_acl_abf_track_implemented')";
        type string {
          length "1..32";
        }
        description
          "specific TRACK Name for this nexthop";
      }
      leaf vrf {
        type string {
          length "1..32";
        }
        description
          "Specific VRF Name for this nexthop";
      }
    }
    container nexthop3 {
      must '(../nexthop2/vrf and ../nexthop2/ipv6) or ../nexthop2/vrf or ../nexthop2/ipv6' {
        tailf:xpath-root 3;
      }
      presence "Forward to specified nexthop on match against this entry";
      description
        "Another nexthop";
      leaf ipv6 {
        type inet:ipv6-address;
        description
          "nexthop3 ipv6 address";
      }
      leaf track {
        tailf:display-when "not(../../ncs:module) or boolean(/ncs:devices/ncs:device[ncs:name=current()/../../ncs:name]/capability/feature='ipv6_acl_abf_track_implemented')";
        type string {
          length "1..32";
        }
        description
          "specific TRACK Name for this nexthop";
      }
      leaf vrf {
        type string {
          length "1..32";
        }
        description
          "Specific VRF Name for this nexthop";
      }
    }
  }

  augment "/ncs:devices/ncs:device/ncs:config" {
    container ipv6 {
      tailf:ncs-device-type "netconf";
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='Cisco-IOS-XR-um-ipv6-access-list-cfg']";
      description
        "Configure ipv6 access-list";
      container access-list-options {
        container log-update {
          description
            "Control access lists log updates";
          leaf threshold {
            type uint32 {
              range "1..2147483647" {
                description
                  "Log update threshold (number of hits)";
              }
            }
            description
              "Set access-list logging threshold";
          }
          leaf rate {
            type uint16 {
              range "1..1000" {
                description
                  "rate (num. logs per second)";
              }
            }
            description
              "Set access-list logging rate (num. logs per second)";
          }
        }
      }
      container access-lists {
        description
          "Access-lists";
        list access-list {
          key "access-list-name";
          description
            "Access-list commands";
          leaf access-list-name {
            type string {
              length "1..64";
            }
            description
              "Access list name - maximum 64 characters";
          }
          container sequences {
            description
              "Access list entries";
            list sequence {
              must 'deny or permit or remark' {
                tailf:xpath-root 3;
              }
              key "sequence-number";
              description
                "access list entry";
              leaf sequence-number {
                type uint32 {
                  range "1..2147483643";
                }
                description
                  "Sequence number for this entry";
              }
              container deny {
                must '(protocol or eq or range) and (source and destination) and (not(log and log-input))' {
                  tailf:xpath-root 3;
                }
                presence "Grant type Deny";
                uses protocol-common;
                uses ace-common;
                uses match-option-common;
                container icmp-off {
                  presence "Do not generate the ICMP message";
                  description
                    "Do not generate the ICMP message";
                }
              }
              container permit {
                must '(protocol or eq or range) and (source and destination) and (not(log and log-input))' {
                  tailf:xpath-root 3;
                }
                presence "Grant type Permit";
                uses protocol-common;
                uses ace-common;
                uses nexthops;
                uses match-option-common;
              }
              leaf remark {
                type string {
                  length "0..255";
                }
                description
                  "Comment for access list";
              }
            }
          }
        }
      }
    }
  }
  augment "/ncs:devices/ncs:device/ncs:live-status" {
    container ipv6 {
      tailf:ncs-device-type "netconf";
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='Cisco-IOS-XR-um-ipv6-access-list-cfg'] or (../../ncs:live-status-protocol[not(ncs:capability)]) or (../../ncs:live-status-protocol/ncs:capability/ncs:module[.='Cisco-IOS-XR-um-ipv6-access-list-cfg'])";
      description
        "Configure ipv6 access-list";
      container access-list-options {
        container log-update {
          description
            "Control access lists log updates";
          leaf threshold {
            type uint32 {
              range "1..2147483647" {
                description
                  "Log update threshold (number of hits)";
              }
            }
            description
              "Set access-list logging threshold";
          }
          leaf rate {
            type uint16 {
              range "1..1000" {
                description
                  "rate (num. logs per second)";
              }
            }
            description
              "Set access-list logging rate (num. logs per second)";
          }
        }
      }
      container access-lists {
        description
          "Access-lists";
        list access-list {
          key "access-list-name";
          description
            "Access-list commands";
          leaf access-list-name {
            type string {
              length "1..64";
            }
            description
              "Access list name - maximum 64 characters";
          }
          container sequences {
            description
              "Access list entries";
            list sequence {
              // NCS drop must statement
              key "sequence-number";
              description
                "access list entry";
              leaf sequence-number {
                type uint32 {
                  range "1..2147483643";
                }
                description
                  "Sequence number for this entry";
              }
              container deny {
                // NCS drop must statement
                presence "Grant type Deny";
                uses live_ncs_protocol-common;
                uses live_ncs_ace-common;
                uses live_ncs_match-option-common;
                container icmp-off {
                  presence "Do not generate the ICMP message";
                  description
                    "Do not generate the ICMP message";
                }
              }
              container permit {
                // NCS drop must statement
                presence "Grant type Permit";
                uses live_ncs_protocol-common;
                uses live_ncs_ace-common;
                uses live_ncs_nexthops;
                uses live_ncs_match-option-common;
              }
              leaf remark {
                type string {
                  length "0..255";
                }
                description
                  "Comment for access list";
              }
            }
          }
        }
      }
    }
  }
  augment "/ncs:devices/ncs:template/ncs:ned-id/ncs:config" {
    container ipv6 {
      description
        "Configure ipv6 access-list";
      container access-list-options {
        container log-update {
          description
            "Control access lists log updates";
          leaf threshold {
            type string;
            description
              "Set access-list logging threshold";
          }
          leaf rate {
            type string;
            description
              "Set access-list logging rate (num. logs per second)";
          }
        }
      }
      container access-lists {
        description
          "Access-lists";
        list access-list {
          // NCS patched for predictable order
          ordered-by user;
          key "access-list-name";
          description
            "Access-list commands";
          leaf access-list-name {
            type string;
            description
              "Access list name - maximum 64 characters";
          }
          container sequences {
            description
              "Access list entries";
            list sequence {
              // NCS patched for predictable order
              ordered-by user;
              // NCS drop must statement
              key "sequence-number";
              description
                "access list entry";
              leaf sequence-number {
                type string;
                description
                  "Sequence number for this entry";
              }
              container deny {
                // NCS drop must statement
                presence "Grant type Deny";
                uses ncs_template_protocol-common;
                uses ncs_template_ace-common;
                uses ncs_template_match-option-common;
                container icmp-off {
                  presence "Do not generate the ICMP message";
                  description
                    "Do not generate the ICMP message";
                }
              }
              container permit {
                // NCS drop must statement
                presence "Grant type Permit";
                uses ncs_template_protocol-common;
                uses ncs_template_ace-common;
                uses ncs_template_nexthops;
                uses ncs_template_match-option-common;
              }
              leaf remark {
                type string;
                description
                  "Comment for access list";
              }
            }
          }
        }
      }
    }
  }

  feature ipv6_acl_undetermined_transport_supported {
    description
      "Undetermined transport packet";
  }

  feature ipv6_acl_is_set_ttl_supported {
    description
      "Set ttl value";
  }

  feature ipv6_acl_is_set_qos_group_supported {
    description
      "Set QoS group";
  }

  feature ipv6_acl_is_set_action_supported {
    description
      "Set action on access-list entry";
  }

  feature ipv6_acl_capture_implemented {
    description
      "Capture matched packet";
  }

  feature ipv6_acl_is_udf_supported {
    description
      "Set User Defined Fields";
  }

  feature ipv6_acl_pktlen_implemented {
    description
      "Check packet length";
  }

  feature IP_ACL_TCP_FLEXFLAGS_IMPLEMENTED {
    description
      "Match all the options specified for TCP flags";
  }

  feature IP_ACL_TCP_URG_FLAG_IMPLEMENTED {
    description
      "Match on URG bit";
  }

  feature ipv6_acl_rollback_permit_supported {
    description
      "Rollback of access-list";
  }

  feature ipv6_acl_abf_track_implemented {
    description
      "Match a specific TRACK Name";
  }

  feature ipv6_acl_abf_implemented {
    description
      "Forward to specified nexthop on match against access-list entry";
  }

  feature ipv6_acl_protocol_range_implemented {
    description
      "Range of protocol numbers";
  }

  feature ipv6_acl_counter_supported {
    description
      "Counter for access-list entry";
  }

  feature ipv6_acl_object_groups_supported {
    description
      "Port object group";
  }
}
